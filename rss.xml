<?xml version="1.0" encoding="utf-8"?>






<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Shaohan.Niu&#39;s Tech Blog</title>
        <link>https://chaintechinfo.github.io/</link>
        <description>MemE 是一个强大且可高度定制的 GoHugo 博客主题，专为个人博客设计。</description>
        <generator>Hugo 0.78.2 https://gohugo.io/</generator>
        
            <language>zh-CN</language>
        
        
            <managingEditor>shaohan.niu.share@gmail.com (shaohan.niu)</managingEditor>
        
        
            <webMaster>shaohan.niu.share@gmail.com (shaohan.niu)</webMaster>
        
        
            <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
        
        <lastBuildDate>Mon, 07 Dec 2020 10:01:04 &#43;0800</lastBuildDate>
        
            <atom:link rel="self" type="application/rss&#43;xml" href="https://chaintechinfo.github.io/rss.xml" />
        
        
            <item>
                <title>Kubernetes Best Practices: Mapping External Services</title>
                <link>https://chaintechinfo.github.io/posts/cloud-native/kubernetes/kubernetes-best-practices-mapping-external-services/</link>
                <guid isPermaLink="true">https://chaintechinfo.github.io/posts/cloud-native/kubernetes/kubernetes-best-practices-mapping-external-services/</guid>
                <pubDate>Tue, 24 Nov 2020 16:44:14 &#43;0800</pubDate>
                
                    <author>shaohan.niu.share@gmail.com (shaohan.niu)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;在使用 Kubernetes 集群时，我们有访问外部服务的需要，比如一些公共的 API 服务，或者是自己自建的一些数据存储服务等。&lt;/p&gt;
&lt;p&gt;如果在不同环境中的应用程序连接到相同的外部 Endpoint，并且没有计划将外部服务引入 Kubernetes 集群，那么直接在代码中使用外部服务 Endpoint 是完全可以的。但是，有些情况是例外的，比如某些 Cloud Native 的数据库（例如 Cloud Firestore 或 Cloud Spanner）使用单个端点进行所有访问，但大多数数据库对于不同实例具有单独的端点。&lt;/p&gt;
&lt;p&gt;一种解决方法是：使用 ConfigMap。只需将端点地址存储在 ConfigMap 中，然后在代码中将其用作环境变量。这个解决方案有效，但存在一些缺点：需要修改 ConfigMap 并编写其他代码以从环境变量中读取；但最重要的是，如果端点地址发生更改，则可能需要重新启动所有正在运行的容器以获取更新的端点地址。而 Kubernetes 为我们提供了内置的服务发现机制来更好的解决这个问题。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-如何做外部服务映射&#34;&gt;Kubernetes 如何做外部服务映射&lt;/h2&gt;
&lt;p&gt;Kubernetes 的内置服务发现机制为集群外运行的服务提供服务，就像为集群内的服务一样！这使得跨开发环境和产品环境提供了方便，并且如果最终将服务移至群集内，则完全不必更改代码。&lt;/p&gt;
&lt;h3 id=&#34;在-kubernetes-群集外具有-ip-地址的数据库做服务映射&#34;&gt;在 Kubernetes 群集外具有 IP 地址的数据库做服务映射&lt;/h3&gt;
&lt;p&gt;这种场景比较常见：在 Kubernetes 集群外有一个独立的数据库服务，需要让集群内的服务可以访问到这个带有 IP 地址的外部服务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先创建一个 Service&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;external-mysql-svc&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;Spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ClusterIP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;3306&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;targetPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;13306&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这个服务没有 Pod 选择器，在创建 Service 后，并不知道将流量发送到哪里，接下来需要创建一个 Endpoint，该对象将接收来自该服务的流量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;再创建一个 Endpoint&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Endpoints&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;external-mysql-svc&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subsets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;addresses&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;10.240.0.4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;13306&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Endpoint 手动定义了数据库的 IP 地址，并且使用了与 Service 相同的名称。 Kubernetes 使用 Endpoint 中定义的所有 IP 地址，就像它们是常规的 Kubernetes Pod 一样。&lt;/p&gt;
&lt;p&gt;然后就可以使用下面的方式在应用服务中访问数据库：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;jdbc:mysql://external-mysql-svc/test?useSSL&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;false&lt;span class=&#34;p&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;characterEncoding&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;utf8
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这种方式完全不需要在代码中使用 IP 地址！如果将来 IP 地址发生变化，则可以使用新的 IP 地址更新 Endpoint，并且应用程序无需进行任何更改.&lt;/p&gt;
&lt;h3 id=&#34;在-kubernetes-群集外具有-uri-地址的数据库做服务映射&#34;&gt;在 Kubernetes 群集外具有 URI 地址的数据库做服务映射&lt;/h3&gt;
&lt;p&gt;如果使用的是来自第三方的托管数据库服务，则很可能会提供了可用于连接的统一资源标识符（URI）。三方托管的服务可能为不同的环境提供了不同的 URI 地址：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// dev 环境
mongodb://&amp;lt;dbuser&amp;gt;:&amp;lt;dbpassword&amp;gt;@ds149763.mlab.com:49763/dev

// prod 环境
mongodb://&amp;lt;dbuser&amp;gt;:&amp;lt;dbpassword&amp;gt;@ds145868.mlab.com:45868/prod
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个时候可以创建 ExternalName Service，这提供了静态 Kubernetes 服务，可将流量重定向到外部服务。此服务在内核级别执行简单的 CNAME 重定向，因此对性能的影响很小。如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;mongo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ExternalName&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;externalName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ds149763.mlab.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;由于 ExternalName 使用 CNAME 重定向，因此无法进行端口映射。对于具有静态端口的服务，这种方式会更加适用。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过将外部服务映射到内部服务，可以灵活地将来将这些服务引入群集中，同时最大程度地减少重构工作。此外，它使管理和了解正在使用哪些外部服务变得更加容易。&lt;/p&gt;
&lt;p&gt;如果外部服务具有有效的域名，并且不需要重新映射端口，则使用 ExternalName 服务类型是将外部服务映射到内部服务的简便快捷方式。如果没有域名或需要进行端口重新映射，只需将 IP 地址添加到 Endpoint 并使用它即可。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a href=&#34;https://cloud.google.com/blog/products/gcp/kubernetes-best-practices-mapping-external-services&#34;&gt;https://cloud.google.com/blog/products/gcp/kubernetes-best-practices-mapping-external-services&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;via: &lt;a href=&#34;https://blog.opskumu.com/kubernetes-ext-service.html&#34;&gt;https://blog.opskumu.com/kubernetes-ext-service.html&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://chaintechinfo.github.io/categories/cloud-native/">Cloud Native</category>
                                
                            
                                
                                
                                
                                    <category domain="https://chaintechinfo.github.io/categories/kubernetes/">Kubernetes</category>
                                
                            
                                
                                
                                
                                    <category domain="https://chaintechinfo.github.io/categories/best-practices/">Best Practices</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://chaintechinfo.github.io/tags/cloud-native/">Cloud Native</category>
                                
                            
                                
                                
                                
                                    <category domain="https://chaintechinfo.github.io/tags/kubernetes/">Kubernetes</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Guava EventBus</title>
                <link>https://chaintechinfo.github.io/posts/sourcecode/guava/guava-eventbus/</link>
                <guid isPermaLink="true">https://chaintechinfo.github.io/posts/sourcecode/guava/guava-eventbus/</guid>
                <pubDate>Mon, 16 Nov 2020 17:52:08 &#43;0800</pubDate>
                
                    <author>shaohan.niu.share@gmail.com (shaohan.niu)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;Guava EventBus 允许组件之间的发布-订阅式通信，而无需组件之间显式注册。&lt;/p&gt;
&lt;p&gt;适用场景：进程内通信，不支持进程间，不是一个通用的发布订阅系统，使用显式注册代替传统的 Java 进程内事件分发，传统的事件分发需要定义 Listener、注册每个事件监听到列表中等&lt;/p&gt;
&lt;h2 id=&#34;使用-eventbus&#34;&gt;使用 EventBus&lt;/h2&gt;
&lt;p&gt;感受一下 EventBus 的简单与强悍&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;EventBus01&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;EventBus&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eventBus&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;EventBus&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;OrderEventBus&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;eventBus&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;register&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;OrderEventSubscribe&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;

        &lt;span class=&#34;n&#34;&gt;eventBus&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;post&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;OrderCreatedEvent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;O187312&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;120&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;eventBus&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;post&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;eventBus&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;post&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;OrderCancelledEvent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;O9999&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()));&lt;/span&gt;

        &lt;span class=&#34;n&#34;&gt;EventBus&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eventBus1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;EventBus&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;exception&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;exception&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;});&lt;/span&gt;

        &lt;span class=&#34;n&#34;&gt;eventBus1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;register&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NoopEventSubscribe&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;eventBus1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;post&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;OrderCreatedEvent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;123&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;13.0&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;OrderEventSubscribe&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nd&#34;&gt;@Subscribe&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;handleOrderCreated&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;OrderCreatedEvent&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Handle 1: &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

        &lt;span class=&#34;nd&#34;&gt;@Subscribe&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;handleOrder2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;OrderCreatedEvent&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Handle 2: &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

        &lt;span class=&#34;nd&#34;&gt;@Subscribe&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;handleOrder3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Handle 3: &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;NoopEventSubscribe&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nd&#34;&gt;@Subscribe&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;handleOrderCreated&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DeadEvent&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Dead Handle 1: &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RuntimeException&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Mock&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;nd&#34;&gt;@Data&lt;/span&gt;
    &lt;span class=&#34;nd&#34;&gt;@ToString&lt;/span&gt;
    &lt;span class=&#34;nd&#34;&gt;@AllArgsConstructor&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;OrderCreatedEvent&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;orderId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;amount&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;nd&#34;&gt;@Data&lt;/span&gt;
    &lt;span class=&#34;nd&#34;&gt;@ToString&lt;/span&gt;
    &lt;span class=&#34;nd&#34;&gt;@AllArgsConstructor&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;OrderCancelledEvent&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;orderId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cancelledAt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;事件的订阅者通过 @Subscribe 来标识，是方法级别的。&lt;/p&gt;
&lt;p&gt;为什么使用注解标记处理，而不是要求侦听器实现接口？因为注解可以表达接口想要表达的意图，此外注解可以允许你将事件处理程序放在任意想放置的地方，灵活性更好。传统的 Java 事件使用一个监听器接口，有几个缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;任何一个类只能对给定事件实现单个响应&lt;/li&gt;
&lt;li&gt;侦听器接口方法可能会冲突&lt;/li&gt;
&lt;li&gt;该方法必须以事件（例如handleChangeEvent）命名，而不是其用途（例如recordChangeInJournal）命名&lt;/li&gt;
&lt;li&gt;每个事件通常都有其自己的接口，而没有用于一系列事件（例如，所有UI事件）的公共父接口&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用传统的 Java 的方式由于难以干净利落地实现，因此产生了一种模式，特别是在 Swing 应用程序中常见的模式，即使用微小的匿名类来实现事件监听器接口。如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ChangeRecorder&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;setCustomer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Customer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cust&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 使用匿名类实现特定的 Listener 接口
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;cust&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;addChangeListener&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ChangeListener&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;customerChanged&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ChangeEvent&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;recordChange&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getChange&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;};&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果使用了 EventBus, 就是如下这样的，对比明显：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Class is typically registered by the container.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;EventBusChangeRecorder&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 使用 EventBus 的注解来实现
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nd&#34;&gt;@Subscribe&lt;/span&gt; 
  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;recordCustomerChange&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ChangeEvent&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;recordChange&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getChange&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;理解-eventbus-的设计&#34;&gt;理解 EventBus 的设计&lt;/h2&gt;
&lt;p&gt;EventBus 内部有 4 个重要的组件：executor, exceptionHandler, subscribers, dispatcher&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;subscribers 用来存放所有已经注册到当前 EventBus 的订阅者, 它的实现是一个订阅者注册表 SubscriberRegistry&lt;/li&gt;
&lt;li&gt;dispatcher 分发事件给订阅者的处理器，提供了不同场景下的不同事件分发顺序的保证，比如 perThreadDispatchQueue 确保每个线程内部发布的事件是有序的；immediate 表示立即消息，当消息发布后会被立即执行；legacyAsync 使用了一个全局队列来存储当前 EventBus 所有已发布的事件，然后分发给 executor 处理&lt;/li&gt;
&lt;li&gt;executor 任务执行器的抽象，在 EventBus 中承担调用执行订阅者的职责，依赖该抽象既可以实现同步调用订阅者，也可以实现异步调用，满足了不同场景的灵活度，AsyncEventBus 就是一个可以灵活定制 Executor 的可实现异步执行调用者的类&lt;/li&gt;
&lt;li&gt;exceptionHandler EventBus 提供了一个默认的异常处理器，但自定义的异常处理器可以满足对异常处理的特殊需求&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;EventBus 发布事件的流程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据 event 查询事件订阅者列表&lt;/li&gt;
&lt;li&gt;如果该事件有订阅者，事件分发器将事件分发给订阅者，其中 Subscriber 表示一个订阅者，包含了目标对象和需要执行的方法，订阅者在执行时会将方法的调用执行委托给 executor，在执行调用订阅者时使用了反射机制；如果在执行过程中出现异常，交给 exceptionHandler 去处理，整个处理结束&lt;/li&gt;
&lt;li&gt;如果事件没有订阅者，事件就被当作 DeadedEvent 进行处理，如果注册了 DeadedEvent 的订阅者，那么就会处理 DeadedEvent，否则会丢弃这个事件&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;eventbus-实现&#34;&gt;EventBus 实现&lt;/h3&gt;
&lt;p&gt;EventBus 的两个核心是 register subscribe 和 post event&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;register subscribe&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SubscriberRegistry 是注册 Subscriber 的地方，为了实现一个线程安全的 EventBus，SubscriberRegistry 内部使用了 ConcurrentMap 作为存放 Subscriber 的容器，并且在需要更新 Subscriber 时，利用了具有写时复制能力的 CopyOnWriteArraySet，这样在并发注册 Subscriber 时也可以保证线程安全和正确性，之所以使用 CopyOnWriteArraySet 是因为注册订阅者是一个小概率发生的事情，一般情况下都是在启动时注册，运行时使用，一个典型的读多写少的场景。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note: 在平常编写程序时，应该多思考具体的应用场景来选择合适的数据结构和算法，这样能最大化程序的性能，同时也让设计和实现变得优雅，这是一个工程师的内核能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/** Registers all subscriber methods on the given listener object. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;register&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;listener&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 使用 MultiMap 存储 Subscriber, e.g.: 
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//  io.github.demo.OrderCreatedEvent -&amp;gt; [Subscriber1, Subscriber2]
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;Multimap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;?&amp;gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Subscriber&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;listenerMethods&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;findAllSubscribers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;listener&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Entry&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;?&amp;gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Collection&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Subscriber&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;entry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;listenerMethods&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;asMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;entrySet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;Class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eventType&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;entry&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;Collection&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Subscriber&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eventMethodsInListener&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;entry&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getValue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      
      &lt;span class=&#34;c1&#34;&gt;// CopyOnWriteArraySet 存储 Subscriber 的列表，这个列表里的订阅者按顺序处理事件
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;CopyOnWriteArraySet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Subscriber&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eventSubscribers&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;subscribers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;

      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventSubscribers&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;CopyOnWriteArraySet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Subscriber&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newSet&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CopyOnWriteArraySet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;eventSubscribers&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;MoreObjects&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;firstNonNull&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;subscribers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;putIfAbsent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newSet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newSet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

      &lt;span class=&#34;c1&#34;&gt;// 添加最新注册的订阅者，使用写时复制机制
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;eventSubscribers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;addAll&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventMethodsInListener&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 发送事件时，就从 eventSubscribers 中查询订阅者列表，它返回的是一个快照
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/**
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Gets an iterator representing an immutable snapshot of all subscribers to the given event at
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * the time this method is called.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Iterator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Subscriber&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getSubscribers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;ImmutableSet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;?&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eventTypes&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flattenHierarchy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getClass&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Iterator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Subscriber&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;subscriberIterators&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;Lists&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;newArrayListWithCapacity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventTypes&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;

    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eventType&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eventTypes&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;CopyOnWriteArraySet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Subscriber&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eventSubscribers&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;subscribers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventSubscribers&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// eager no-copy snapshot
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;subscriberIterators&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventSubscribers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;iterator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Iterators&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;concat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;subscriberIterators&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;iterator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;post event&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 发布事件
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;post&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 获取订阅者列表
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;Iterator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Subscriber&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eventSubscribers&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;subscribers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getSubscribers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventSubscribers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;hasNext&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 分发事件，订阅者按顺序执行
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// dispatcher 的默认实现有三个实现策略：
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;//  1. PerThreadQueuedDispatcher  每个线程使用一个 Queue 存储 event，使用了 ThreadLocal 并发模式
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;//  2. LegacyAsyncDispatcher  同一个 EventBus 内部使用一个全局的队列存放 event
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;//  3. ImmediateDispatcher  立即执行，不使用队列存储
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;dispatcher&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;dispatch&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eventSubscribers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(!(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;instanceof&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DeadEvent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// the event had no subscribers and was not itself a DeadEvent
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;// 如果找不到订阅者，就生成一个 DeadedEvent 发布出去
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;post&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DeadEvent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;EventBus 虽然是实现了一个小功能，但他内部的设计与实现是非常值得学习的。有几个设计上的点值得思考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;封装复杂性，提供简单、易用、清晰的接口，在使用 EventBus 时，我们只需要定义事件和实现事件的订阅者，然后注册到 EventBus 中，就可以轻松实现进程内的事件通信，支持一个事件被多个订阅者消费；&lt;/li&gt;
&lt;li&gt;使用更加能表达意图的 @Subscribe 注解来声明订阅者，而不是实现特定接口，使得编程时代码的灵活度更好，因为可以在任何应该放置订阅者的地方放置这个订阅者，而不是被强制实现接口和使用一个固定的方法名(因为接口是事先定义好的)；&lt;/li&gt;
&lt;li&gt;在设计与实现时，尽量使用 OO 设计原则和设计思想, 将 EventBus 的功能划分为功能相对清晰单一的子功能，然后进行组合，比如抽象出普适的 Object event；抽象出 Subscriber, 并使用 @Subscribe 和反射机制来自动扫描、自动发现 Subscriber; 抽象出 Dispatcher 进行事件分发，进而实现满足不同需求的分发策略；抽象出 Executor，将 Subscriber 的执行委托给 Executor，进而可以灵活的控制是异步执行还是同步执行等；抽象出 exceptionHandler 来处理异常，并且可以将异常传播给自定义的异常处理组件，由开发者控制&lt;/li&gt;
&lt;li&gt;根据应用场景灵活选择并发模式(ThreadLocal, 并发写控制等)、数据结构与算法(CopyOnWriteArraySet, MultiMap, Queue etc.)等&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/google/guava/wiki/EventBusExplained&#34;&gt;EventBus Explained&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tianqun2019.com/topic/145&#34;&gt;Guava-EventBus 使用详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://chaintechinfo.github.io/categories/source-code/">Source Code</category>
                                
                            
                                
                                
                                
                                    <category domain="https://chaintechinfo.github.io/categories/guava/">Guava</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://chaintechinfo.github.io/tags/source-code/">Source Code</category>
                                
                            
                                
                                
                                
                                    <category domain="https://chaintechinfo.github.io/tags/guava/">Guava</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Network: 计算机网络基础知识</title>
                <link>https://chaintechinfo.github.io/posts/core-skills/network/network-basic/</link>
                <guid isPermaLink="true">https://chaintechinfo.github.io/posts/core-skills/network/network-basic/</guid>
                <pubDate>Sun, 25 Oct 2020 22:00:29 &#43;0800</pubDate>
                
                    <author>shaohan.niu.share@gmail.com (shaohan.niu)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;本文主要汇总在计算机网络中使用的基本概念、基本术语和一些常识。&lt;/p&gt;
&lt;h2 id=&#34;网络协议&#34;&gt;网络协议&lt;/h2&gt;
&lt;p&gt;毋庸置疑，协议是重要的，随处可见又非常必要。如果我们讨论计算机网络下的协议，它就是计算机与计算机之间通过网络通信时事先达成的一种&amp;quot;约定&amp;quot;。这种约定使那些由不同厂商的设备、不同的 CPU 以及不同的操作系统组成的计算机之间，只要遵循相同的协议就能够实现通信。协议是不同实体之间通信的基础，它也是不同厂商能够实现分工的基础。&lt;/p&gt;
&lt;p&gt;而计算机网络世界中的协议是由一些专门的组织来制定的，不管是网络提供商，还是设备商，还是使用者，都遵循这个协议。如果没有一套标准的网络协议，每个厂商、每个提供商都有自己的一套东西，那么这个世界就会变得混乱，因为没有人知道对方在讲什么，标准化是趋势也是必然。ISO 制定了国际标准 OSI，对通信做了标准化，但是 TCP/IP 并不是 ISO 制定的，而是由 IETF 建议和推进的，目前落地的网络协议是 TCP/IP 协议族。比如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;物理层&lt;/li&gt;
&lt;li&gt;链路层: ARP, VLAN, STP&lt;/li&gt;
&lt;li&gt;网络层: ICMP, IP, OSPF, BGP, IPSec, GRE&lt;/li&gt;
&lt;li&gt;传输层: TCP, UDP&lt;/li&gt;
&lt;li&gt;应用层: DHCP, HTTP, HTTPS, P2P, DNS, RPC, GTP, RTMP&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外一个比较重要的东西是传输，如何将一台计算机上的数据传输到其他计算机或者网络设备上。从不同的上下文来讲，传输也有不同的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在网络协议传输层中传输的含义是一个高层抽象的概念，它假定了由下层来完成实际的数据传输，传输层来对数据传输做控制。根据发送方式可以归为面向有连接和面向无连接。面向有连接是在发送数据前先打开一个连接，然后发送数据，发送完成后关闭连接，如果无法建立连接就可以避免发送无谓的数据；面向无连接不要求建立连接，可以自由发送数据&lt;/li&gt;
&lt;li&gt;在物理层和链路层，传输的含义是实实在在的将 bit 数据从一个设备发送到另一个设备&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;两种网络通信方式电路交换和分组交换&#34;&gt;两种网络通信方式：电路交换和分组交换&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;电路交换的历史比较久，主要用于电话网时代。在电路交换中，交换机主要负责数据的中转处理，计算机首先被连接到交换机上，交换机与交换机之间有诸多通信线路连接，在通信使需要通过交换机与目标主机建立连接，一旦成功建立连接，用户就可以一直使用这个连接，直到连接被断开；如果有很多个计算机之间需要通信，这种通信方式就会有问题，因为通信线路毕竟是有限的，过多的并发用户会导致通信线路不够，从而无法实现正常通信；&lt;/li&gt;
&lt;li&gt;分组交换是一种新的交换技术，他解决了电路交换的痛点，基本原理是将计算机所有发送的数据分成多个数据包，按照一定的顺序排列后分别发送；在分组交换的方式下，所有的计算机可以同时收发数据，提高了通信线路的利用率；一个重要的问题是：在分组交换方式下，如何避免数据包的混乱，也就是说如何区分 A 发给 B 的数据包与 A 发给 C 的数据包呢？使用的方式就是在分组数据中写入发送方和收取方的地址。可以说分组交换是 TCP/IP 得以实现的基石。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;单播--广播--多播--任播&#34;&gt;单播 / 广播 / 多播 / 任播&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;单播是一种 1 对 1 的通信方式，固定电话通信就是一种单播的例子&lt;/li&gt;
&lt;li&gt;广播是在同一个数据链内的网络设备可以收到广播消息&lt;/li&gt;
&lt;li&gt;多播相对于广播，限定了范围，只有在特定组内的网络设备才可以接收到数据&lt;/li&gt;
&lt;li&gt;任播是在特定的多台主机中任意选择一台符合要求的主机，然后和这个主机进行通信，比如 DNS 根域名解析器&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;计算机网络实际的构成要素&#34;&gt;计算机网络实际的构成要素&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;网卡，每个计算机都必须至少有一个物理网卡才能实现网络通信&lt;/li&gt;
&lt;li&gt;中继器和集线器，中继器是对减弱的信号进行放大和发送的设备；中继器通过物理层的连接延长网络；即使在数据链路层出现某些错误，中继器仍然转发数据；中继器无法改变传输速率；可见，中继器工作在物理层&lt;/li&gt;
&lt;li&gt;网桥 / 2 层交换机&lt;/li&gt;
&lt;li&gt;路由器 / 3 层交换机&lt;/li&gt;
&lt;li&gt;4 ～ 7 层交换机，比如负载均衡器设备，广域网加速器等&lt;/li&gt;
&lt;li&gt;网关，它负责协议的转换和数据的转发，在同一种类型的协议之间转发数据叫做应用网关&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据链路&#34;&gt;数据链路&lt;/h2&gt;
&lt;p&gt;计算机网络最基础的东西就是数据链路，它构成了整个网络的基础物理通道。当然数据链路层也有协议，它定义了通过通信媒介互连的设备之间传输的规范。数据链路是让互联计算机之间相互通信的一种协议，又指通信手段。&lt;/p&gt;
&lt;p&gt;设备之间在传输数据时，数据链路层和物理层是必不可少的，计算机以0，1二进制来表示信息，而实际的物理通信媒介之间处理的却是电压的高低、光的闪灭以及电波的强弱等信号，把这些信号与二进制的 0，1 进行转换是物理层做的事情；而数据链路层处理的数据不是 0，1 序列，而是把 0，1 序列集合成一个叫做数据帧的块，然后进行传输。数据链路可以被视为网络传输中的最小单位，而互联网可以看作数据链路的集合。&lt;/p&gt;
&lt;h3 id=&#34;从介质来看数据链路&#34;&gt;从介质来看数据链路&lt;/h3&gt;
&lt;p&gt;网络可以分为共享介质和非共享介质。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共享介质型网络&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最早的以太网、FDDI 都是介质共享型网络，这种方式下设备之间使用同一个载波信道进行发送和接收，并且要对介质进行访问控制。根据访问控制方式的不同，可以分为信道竞争和令牌传递等方式，各有不同。在信道竞争方式下，以太网应用的是带冲突检测的载波监听多路访问 (CSMA/CD)，基本原理是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确认链路中没有任何设备发送数据&lt;/li&gt;
&lt;li&gt;开始发送数据&lt;/li&gt;
&lt;li&gt;在发送数据的同时，监控是否出现冲突，通过检测电压的方式等&lt;/li&gt;
&lt;li&gt;如果发生了冲突，就先阻塞报文的发送，然后放弃发送数据，在随机的一段时间后进行重发&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;采用 CSMA/CD 方式的以太网，要先判断是否可以通信，可以通信就独占通信介质发送数据，显然它不能同时接收数据和发送数据，所以说是一种半双工的通信方式；它的缺点是传输速率是受限制的，有时会导致介质的利用率不高&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非共享介质网络&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非共享介质是一种不共享介质的传输控制方式；网络中的每个站都直接连交换机，由交换机负责转发数据帧，发送端和接收端不共享通信介质；目前以太网也采用这种方式，计算机和交换机之间形成一对一的连接，实现了全双工通信，这种方式不会出现冲突，所以实现了更高效的通信。&lt;/p&gt;
&lt;h3 id=&#34;数据帧转发&#34;&gt;数据帧转发&lt;/h3&gt;
&lt;p&gt;在数据链路层需要解决几个问题，在物理层发送数据采用的是广播，在同一个网络环境中的设备都能收到，但是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据包是发给谁的？谁来接收？&lt;/li&gt;
&lt;li&gt;大家都在发，是否有谁先发谁后发的规则，会不会发生混乱？&lt;/li&gt;
&lt;li&gt;发送的时候出错了怎么解决？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数据链路层引入了物理地址的概念，也就是 MAC 地址，也叫链路层地址，在链路层的数据帧中有一个头部，头部写清楚了目标 MAC 地址和源 MAC 地址，同时还有另外一个类型字段，来表示数据帧的数据部分是一个什么类型的数据协议包，一般有 IP / ARP / RARP 等；每个计算机和网络设备都会有一个 MAC 地址，通过数据帧的头部信息就可以判断这个数据包是发给谁的，谁可以接收。&lt;/p&gt;
&lt;p&gt;都在发，是否有谁先发谁后发的规则，会不会发生混乱？以太网使用了随机介入协议来解决这个问题，如果发送数据时网络介质中出现了冲突，就等待一个随机时间后重发。&lt;/p&gt;
&lt;p&gt;对于以太网，数据帧的最后是一个 CRC，用来做数据检测，来计算整个包是否在发送的过程中出现了错误。&lt;/p&gt;
&lt;p&gt;但是在数据转发时，我们在数据帧里封装的是目标机器的 MAC 地址，一开始每个机器是不知道另外一个机器的 MAC 地址的，怎么办？这个时候就可以通过 ARP 协议来查找，ARP 协议就是通过 IP 地址查找 MAC 地址的协议，在同一个局域网中，当知道了一个机器的 IP 地址后，通过发送广播包的方式来获取 MAC 地址，拥有目标 IP 的机器会回复一个数据包来应答，告诉询问的机器它的 MAC 地址是多少；这个时候这台机器就知道了 IP 地址和 MAC 地址的对应关系，就可以缓存在自己这里，下次就可以通过查表的方式找到某个 IP 对应的 MAC（当然这个缓存是有一定过期时间的）&lt;/p&gt;
&lt;p&gt;通常情况下，在一个局域网中的多台计算机是连接在一个或多个交换机上的，当发出一个数据包时，交换机负责接收数据包并从特定的端口发送出去（因为所有端口都转发，会浪费带宽资源），但是交换机是怎么知道从哪个口发送出去的呢？因为交换机具备自学的能力，并且在交换机内部有一个转发表，记录了某个 MAC 地址对应的端口，但这个转发表是有过期时间的。&lt;/p&gt;
&lt;h3 id=&#34;环路检测&#34;&gt;环路检测&lt;/h3&gt;
&lt;p&gt;我们知道交换机有自学能力的，但是当交换机的数量多了以后，网络的拓扑结构就会变的复杂起来，既有可能会遇到环路问题，让网络包迷路，这个时候该怎么办？环路问题的起因是由于同一个数据帧在环路中不端的被转发，这种数据帧在网络中越积越多，最终会导致网络瘫痪。&lt;/p&gt;
&lt;p&gt;STP 协议就是一种解决环路问题的方式。STP 协议比较复杂，日后补充。&lt;/p&gt;
&lt;h3 id=&#34;vlan&#34;&gt;VLAN&lt;/h3&gt;
&lt;p&gt;机器多了之后，交换机也会变多，就算交换机比 Hub 智能一些，但是还是难免有广播的问题，一种解决方式就是使用虚拟隔离，也就是 VLAN 虚拟局域网。&lt;/p&gt;
&lt;p&gt;使用 VLAN，一个交换机上会连属于多个局域网的机器，那交换机怎么区分哪个机器属于哪个局域网呢？只需要在原来的二层的头上加一个 TAG，里面有一个 VLAN ID，一共 12 位，如下图。如果交换机是支持 VLAN 的，当这个交换机把二层的头取下来的时候，就能够识别这个 VLAN ID。这样只有相同 VLAN 的包，才会互相转发，不同 VLAN 的包，是看不到的。这样广播问题和安全问题就都能够解决了。(可以设置交换机每个口所属的 VLAN。)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://chaintechinfo.github.io/img/network/network-dll-vlan-frame.jpeg&#34; alt=&#34;vlan frame&#34;&gt;&lt;/p&gt;
&lt;p&gt;交换机之间怎么连接呢？将两个交换机连接起来的口应该设置成什么 VLAN 呢？对于支持 VLAN 的交换机，有一种口叫作 Trunk 口。它可以转发属于任何 VLAN 的口。交换机之间可以通过这种口相互连接。&lt;/p&gt;
&lt;h3 id=&#34;以太网&#34;&gt;以太网&lt;/h3&gt;
&lt;p&gt;以太网是目前使用最广泛的数据链路。怎么理解以太网？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;是一种通信方式&lt;/li&gt;
&lt;li&gt;有一整套规范和协议&lt;/li&gt;
&lt;li&gt;以太网下的网卡和驱动程序实现简单，相对其他类型的通信方式实现要更加低廉&lt;/li&gt;
&lt;li&gt;现在，以太网支持高速网络，已经成为最具兼容性和未来发展性的一种数据链路&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;重新认识-ping&#34;&gt;重新认识 ping&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://chaintechinfo.github.io/img/network/network-ping-01.jpg&#34; alt=&#34;ping&#34;&gt;&lt;/p&gt;
&lt;p&gt;ping 命令执行的时候，源主机首先会构建一个 ICMP 请求数据包，ICMP 数据包内包含多个字段。最重要的是两个，第一个是类型字段，对于请求数据包而言该字段为 8；另外一个是顺序号，主要用于区分连续 ping 的时候发出的多个数据包。每发出一个请求数据包，顺序号会自动加 1。为了能够计算往返时间 RTT，它会在报文的数据部分插入发送时间。&lt;/p&gt;
&lt;p&gt;然后，由 ICMP 协议将这个数据包连同地址 192.168.1.2 一起交给 IP 层。IP 层将以 192.168.1.2 作为目的地址，本机 IP 地址作为源地址，加上一些其他控制信息，构建一个 IP 数据包。&lt;/p&gt;
&lt;p&gt;接下来，需要加入 MAC 头。如果在本节 ARP 映射表中查找出 IP 地址 192.168.1.2 所对应的 MAC 地址，则可以直接使用；如果没有，则需要发送 ARP 协议查询 MAC 地址，获得 MAC 地址后，由数据链路层构建一个数据帧，目的地址是 IP 层传过来的 MAC 地址，源地址则是本机的 MAC 地址；还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。&lt;/p&gt;
&lt;p&gt;主机 B 收到这个数据帧后，先检查它的目的 MAC 地址，并和本机的 MAC 地址对比，如符合，则接收，否则就丢弃。接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。同样，IP 层检查后，将有用的信息提取后交给 ICMP 协议。&lt;/p&gt;
&lt;p&gt;主机 B 会构建一个 ICMP 应答包，应答数据包的类型字段为 0，顺序号为接收到的请求数据包中的顺序号，然后再发送出去给主机 A。在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 应答包，则说明目标主机可达。此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。&lt;/p&gt;
&lt;p&gt;当然这只是最简单的，同一个局域网里面的情况。如果跨网段的话，还会涉及网关的转发、路由器的转发等等。但是对于 ICMP 的头来讲，是没什么影响的。会影响的是根据目标 IP 地址，选择路由的下一跳，还有每经过一个路由器到达一个新的局域网，需要换 MAC 头里面的 MAC 地址。&lt;/p&gt;
&lt;p&gt;如果在自己的可控范围之内，当遇到网络不通的问题的时候，除了直接 ping 目标的 IP 地址之外，还应该有一个清晰的网络拓扑图。并且从理论上来讲，应该要清楚地知道一个网络包从源地址到目标地址都需要经过哪些设备，然后逐个 ping 中间的这些设备或者机器。如果可能的话，在这些关键点，通过 tcpdump -i eth0 icmp，查看包有没有到达某个点，回复的包到达了哪个点，可以更加容易推断出错的位置。&lt;/p&gt;
&lt;h2 id=&#34;重新认识-traceroute&#34;&gt;重新认识 traceroute&lt;/h2&gt;
&lt;p&gt;traceroute 使用 ICMP 的规则，故意制造一些能够产生错误的场景。&lt;/p&gt;
&lt;p&gt;Traceroute 的第一个作用就是故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。Traceroute 的参数指向某个目的 IP 地址，它会发送一个 UDP 的数据包。将 TTL 设置成 1，也就是说一旦遇到一个路由器或者一个关卡，就表示它“牺牲”了。&lt;/p&gt;
&lt;p&gt;Traceroute 还有一个作用是故意设置不分片，从而确定路径的 MTU。要做的工作首先是发送分组，并设置“不分片”标志。发送的第一个分组的长度正好与出口 MTU 相等。如果中间遇到窄的关口会被卡住，会发送 ICMP 网络差错包，类型为“需要进行分片但设置了不分片位”。每次收到 ICMP“不能分片”差错时就减小分组的长度，直到到达目标主机。&lt;/p&gt;
&lt;p&gt;在 Linux 上，traceroute 命令用于追踪数据包在网络上的传输时的全部路径，它默认发送的数据包大小是40字节。&lt;/p&gt;
&lt;p&gt;通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。&lt;/p&gt;
&lt;p&gt;traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其ip地址。&lt;/p&gt;
&lt;p&gt;traceroute 的使用与解释可以参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://wangchujiang.com/linux-command/c/traceroute.html&#34;&gt;https://wangchujiang.com/linux-command/c/traceroute.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/machangwei-8/p/10353279.html&#34;&gt;https://www.cnblogs.com/machangwei-8/p/10353279.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;重新认识-ifconfig&#34;&gt;重新认识 ifconfig&lt;/h2&gt;
&lt;p&gt;在电脑上查看 ip 地址时，经常使用 ifconfig 或 ipconfig, 有时候也可以使用 ip addr 命令。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ ip addr
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu &lt;span class=&#34;m&#34;&gt;65536&lt;/span&gt; qdisc noqueue state UNKNOWN group default qlen &lt;span class=&#34;m&#34;&gt;1000&lt;/span&gt;
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: enp0s3: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span class=&#34;m&#34;&gt;1500&lt;/span&gt; qdisc fq_codel state UP group default qlen &lt;span class=&#34;m&#34;&gt;1000&lt;/span&gt;
    link/ether 02:6a:93:8d:eb:87 brd ff:ff:ff:ff:ff:ff
    inet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic enp0s3
       valid_lft 86362sec preferred_lft 86362sec
    inet6 fe80::6a:93ff:fe8d:eb87/64 scope link
       valid_lft forever preferred_lft forever
3: enp0s8: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span class=&#34;m&#34;&gt;1500&lt;/span&gt; qdisc fq_codel state UP group default qlen &lt;span class=&#34;m&#34;&gt;1000&lt;/span&gt;
    link/ether 08:00:27:bb:49:66 brd ff:ff:ff:ff:ff:ff
    inet 192.168.33.100/24 brd 192.168.33.255 scope global enp0s8
       valid_lft forever preferred_lft forever
    inet6 fe80::a00:27ff:febb:4966/64 scope link
       valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;运行之后，如果不出意外，会出现类似上面的内容，来分析一下(我使用的是 ubuntu18.04, 其他系统可能会不一样):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有三个网卡，分别是 lo, enp0s3, enp0s8; lo 表示 loopback, 也叫回环地址，专门用来访问本机的, 经过内核处理后直接返回，不会在任何网络中出现，一般通过 127.0.0.1 或者 localhost; enp0s3 和 enp0s8 是两个正常的网卡，但是也稍有不同，主要以 enp0s3 来分析&lt;/li&gt;
&lt;li&gt;为什么叫 enp0s3 而不是类似 eth0 ? 这是一种新的命名方案，叫 &lt;code&gt;Predictable Network Interface&lt;/code&gt;, 名称取决于硬件的物理位置: en 是 &lt;code&gt;ethernet&lt;/code&gt; 的意思，就像 &lt;code&gt;eth&lt;/code&gt; 用于对应 eth0 一样, p 是以太网卡的总线编号, s 是插槽编号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt;&lt;/code&gt; 代表什么呢？它表示的是网络设备的状态标识&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BROADCAST 表示该接口支持广播，MULTICAST 表示该接口支持多播，UP 表示网络接口已启用，LOWER_UP 表示网络电缆已插入，设备已连接至网络&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;mtu 1500 表示最大传输单位（数据包大小）为 1500 字节；mtu 是链路层的概念，MAC 层有 MAC 的头，&lt;strong&gt;以太网规定连 MAC 头带正文合起来，不允许超过 1500 个字节&lt;/strong&gt;。正文里面有 IP 的头、TCP 的头、HTTP 的头。如果放不下，就需要分片来传输。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;qdisc fq_codel state UP group default qlen 1000&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;qdisc 表示排队规则(queueing discipline), 内核如果需要通过某个网络接口发送数据包，它都需要按照为这个接口配置的 qdisc（排队规则）把数据包加入队列。qdisc 将流量队列抽象化，比标准的FIFO队列要复杂得多，实现了内核的流量管理功能，包括流量分类，优先级和速率协商，后续再仔细研究。&lt;/p&gt;
&lt;p&gt;state UP 表示网络接口已经启用；qlen 1000 表示传输队列长度是 1000 个数据包，第 1000 个数据包将排队，第 1001 个数据包将被丢弃。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;link/ether 02:6a:93:8d:eb:87 brd ff:ff:ff:ff:ff:ff&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;link/ether 02:6a:93:8d:eb:87 表示网卡的 MAC 地址；brd ff:ff:ff:ff:ff:ff 表示广播地址, 这个广播地址是全1，说明是一个受限的广播地址，只能在同一个子网中传输，路由器不会转发出去&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;inet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic enp0s3 表示的是 ip 地址信息，10.0.2.15/24 是一种 CIDR 的表示方式；brd 10.0.2.255 是广播地址；scope global 表示全局有效；dynamic enp0s3 表示地址是动态分配的，动态分配一般是通过 DHCP 完成的；参考 &lt;a href=&#34;https://chaintechinfo.github.io/posts/core-skills/network/network-basic/#ip-%E5%9C%B0%E5%9D%80%E5%88%92%E5%88%86&#34;&gt;IP 地址划分&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;valid_lft 86362sec 表示 IPv4 地址的有效使用期限，preferred_lft 表示 IPv4 地址的首选生存期&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;inet6 fe80::a00:27ff:febb:4966/64 scope link 表示 ipv6 地址, scope link 表示私有地址，只在此设备上有效&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ brctl show
bridge name	bridge id		    STP     enabled	      interfaces
docker0		8000.0242d2aa78fc	 no		               veth2b5bd65
                                                      veth40fb187
                                                      veth5303445
                                                      veth64223f0
                                                      veth6fc2d07
                                                      vethb0807c3
                                                      vethb095dc1
                                                      vethfcc2eca
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;brctl show 用来查看当前主机上的虚拟交换机，docker0 是这个虚拟交换机的名称，interfaces 表示加入到这个虚拟交换机的网络设备。&lt;/p&gt;
&lt;h2 id=&#34;网关&#34;&gt;网关&lt;/h2&gt;
&lt;p&gt;网关往往是一个路由器，是一个三层转发的设备。路由器是一台设备，它有五个网口或者网卡，相当于有五只手，分别连着五个局域网。每只手的 IP 地址都和局域网的 IP 地址相同的网段，每只手都是它握住的那个局域网的网关。&lt;/p&gt;
&lt;p&gt;任何一个想发往其他局域网的包，都会到达其中一只手，被拿进来，拿下 MAC 头和 IP 头，看看，根据自己的路由算法，选择另一只手，加上 IP 头和 MAC 头，然后扔出去。&lt;/p&gt;
&lt;p&gt;MAC 地址是一个局域网内才有效的地址。因而，MAC 地址只要过网关，就必定会改变，因为已经换了局域网。两者主要的区别在于 IP 地址是否改变。不改变 IP 地址的网关，我们称为转发网关；改变 IP 地址的网关，我们称为 NAT 网关。&lt;/p&gt;
&lt;p&gt;不是只有路由器才可以作为网关，比如某台 Linux 主机也可以作为网关，只要做好设置；从表现上来看，网关是一个提供了特殊能力的 IP 地址，同一个网段的其他机器，把数据发送到这个 IP 上，然后由网关去处理后面的事情，所以网关具备路由的功能，所以网关一定是运行了具有路由功能的软件，它也一定有一个自己的路由表，来决定下一步的动作。&lt;/p&gt;
&lt;p&gt;详细参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/122ac247f772&#34;&gt;https://www.jianshu.com/p/122ac247f772&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;routing-tables&#34;&gt;Routing tables&lt;/h2&gt;
&lt;p&gt;路由表的作用就是指定下一级网关，根据路由表怎么确定下一级网关，这里就有一个匹配过程，匹配规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最长匹配&lt;/li&gt;
&lt;li&gt;优先级匹配&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;http://linux-ip.net/html/routing-tables.html&#34;&gt;http://linux-ip.net/html/routing-tables.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://linux-ip.net/html/index.html&#34;&gt;http://linux-ip.net/html/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tldp.org/LDP/nag2/nag2.pdf&#34;&gt;https://tldp.org/LDP/nag2/nag2.pdf&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;概念与术语&#34;&gt;概念与术语&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;类别&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;基础概念&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;互联网&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;一个互联网就是一组通过相同协议族互连在一起的网络。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;基础概念&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;广播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;广播是向在同一个网段中的所有主机发送数据包，详细参考 &lt;a href=&#34;https://blog.csdn.net/tennysonsky/article/details/45564479&#34;&gt;广播地址介绍&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;基础概念&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/TUN%E4%B8%8ETAP&#34;&gt;TUN/TAP&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;操作系统内核中的虚拟网络设备, 这些虚拟的网络设备全部用软件实现，并向运行于操作系统上的软件提供与硬件的网络设备完全相同的功能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;链路层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%A9%8B%E6%8E%A5%E5%99%A8&#34;&gt;网桥&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;网桥是一个二层桥接设备，桥接就是把两端连接起来，但不是所有的流量都放行，只有目的 MAC 才可以通过&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;链路层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;MTU&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;最大传输单位，以太网规定 MTU 最大为 1500 字节，其中包括 MAC 头和 MAC 正文&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;内核&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;qdisc&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Queuing Disciplines，排队规则&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;内核&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;fq-codel&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;排队规则的一种，主要致力于解决 &lt;a href=&#34;https://en.wikipedia.org/wiki/Bufferbloat&#34;&gt;bufferbloat&lt;/a&gt; 问题，可参考 &lt;a href=&#34;https://www.jianshu.com/p/3b2e701f61ea&#34;&gt;理解 fq-codl&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;网络延迟&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;bufferbloat&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Bufferbloat&#34;&gt;bufferbloat&lt;/a&gt; 是由数据包过多的缓冲导致数据包交换高延迟，也就是说它会影响某些应用的网络体验，可以翻译为缓冲区膨胀&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;网络相关的一些问题&#34;&gt;网络相关的一些问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;当网络包到达一个路由器的时候，可以通过路由表得到下一跳的 IP 地址，直接通过 IP 地址找就可以了，为什么还要通过本地的 MAC 地址呢？&lt;/li&gt;
&lt;li&gt;net-tools 和 iproute2 有什么关系？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://xiaoz.co/2019/12/14/Linux%E7%BD%91%E7%BB%9C%E6%A0%88%E4%B9%8B%E9%98%9F%E5%88%97-part1/#%E6%8E%92%E9%98%9F%E8%A7%84%E5%88%99-Queuing-Disciplines-QDisc&#34;&gt;Linux网络栈之队列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cacm.acm.org/magazines/2012/1/144810-bufferbloat/fulltext&#34;&gt;Bufferbloat: Dark Buffers in the Internet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://chaintechinfo.github.io/categories/network/">Network</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://chaintechinfo.github.io/tags/network/">Network</category>
                                
                            
                        
                    
                
            </item>
        
    </channel>
</rss>
